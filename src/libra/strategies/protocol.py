"""
Strategy Protocol: Unified interface for trading strategies.

Defines:
- Signal and SignalType for trading signals
- BacktestResult for performance metrics
- Strategy Protocol with lifecycle methods

Design inspired by:
- NautilusTrader Actor/Strategy model
- Backtrader signal framework
- QuantStart event-driven architecture

Same interface works for both backtest and live trading.
"""

from __future__ import annotations

import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta  # noqa: TC003 - used at runtime in dataclass
from decimal import Decimal
from enum import Enum
from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable

import msgspec


if TYPE_CHECKING:
    from libra.gateways.protocol import Tick


# =============================================================================
# Signal Types
# =============================================================================


class SignalType(str, Enum):
    """
    Trading signal types.

    Follows industry conventions from Backtrader, Freqtrade, and NautilusTrader.

    Signal semantics:
    - LONG: Open a long position (or add to existing)
    - SHORT: Open a short position (or add to existing)
    - CLOSE_LONG: Close existing long position
    - CLOSE_SHORT: Close existing short position
    - HOLD: No action, maintain current position

    State transitions:
    - LONG when SHORT position -> close short, then open long
    - SHORT when LONG position -> close long, then open short
    """

    LONG = "LONG"
    SHORT = "SHORT"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"
    HOLD = "HOLD"


class Signal(msgspec.Struct, frozen=True, gc=False):
    """
    Trading signal generated by a strategy.

    Immutable, hashable, and optimized for fast serialization.
    Uses msgspec.Struct for performance on hot path (~95ns creation).

    Attributes:
        signal_type: Type of signal (LONG, SHORT, etc.)
        symbol: Trading pair (e.g., "BTC/USDT")
        timestamp_ns: Signal generation time (nanoseconds since epoch)
        strength: Signal confidence/strength (0.0 to 1.0) for position sizing
        price: Reference price at signal generation
        metadata: Strategy-specific additional data

    Examples:
        # Simple long signal
        signal = Signal(
            signal_type=SignalType.LONG,
            symbol="BTC/USDT",
            timestamp_ns=time.time_ns(),
        )

        # Signal with strength for position sizing
        signal = Signal(
            signal_type=SignalType.LONG,
            symbol="ETH/USDT",
            timestamp_ns=time.time_ns(),
            strength=0.8,
            price=Decimal("2000.00"),
            metadata={"reason": "golden_cross", "fast_ma": 50, "slow_ma": 200},
        )
    """

    signal_type: SignalType
    symbol: str
    timestamp_ns: int

    # Optional fields with defaults
    strength: float = 1.0  # 0.0 to 1.0 for position sizing
    price: Decimal | None = None  # Reference price at signal time
    metadata: dict[str, Any] = {}  # Strategy-specific data

    @classmethod
    def create(
        cls,
        signal_type: SignalType,
        symbol: str,
        strength: float = 1.0,
        price: Decimal | None = None,
        metadata: dict[str, Any] | None = None,
    ) -> Signal:
        """
        Factory method with automatic timestamp.

        Args:
            signal_type: Type of signal
            symbol: Trading pair
            strength: Signal confidence (0.0 to 1.0)
            price: Reference price
            metadata: Additional data

        Returns:
            New Signal instance with current timestamp
        """
        return cls(
            signal_type=signal_type,
            symbol=symbol,
            timestamp_ns=time.time_ns(),
            strength=strength,
            price=price,
            metadata=metadata or {},
        )

    @property
    def timestamp_sec(self) -> float:
        """Timestamp in seconds (float) for compatibility."""
        return self.timestamp_ns / 1_000_000_000

    @property
    def is_entry(self) -> bool:
        """Check if signal is an entry signal (LONG or SHORT)."""
        return self.signal_type in (SignalType.LONG, SignalType.SHORT)

    @property
    def is_exit(self) -> bool:
        """Check if signal is an exit signal (CLOSE_LONG or CLOSE_SHORT)."""
        return self.signal_type in (SignalType.CLOSE_LONG, SignalType.CLOSE_SHORT)

    @property
    def is_hold(self) -> bool:
        """Check if signal is a hold signal."""
        return self.signal_type == SignalType.HOLD


# =============================================================================
# Backtest Result
# =============================================================================


@dataclass
class BacktestResult:
    """
    Comprehensive backtest performance metrics.

    Contains all standard metrics for evaluating strategy performance.
    Uses dataclass since it's created once per backtest (not performance-critical).

    Metric Guidelines:
        Sharpe Ratio: <0.5 poor, 0.5-1.0 acceptable, 1.0-2.0 good, >2.0 excellent
        Max Drawdown: >40% poor, 20-40% acceptable, 10-20% good, <10% excellent
        Win Rate: <40% poor, 40-50% acceptable, 50-60% good, >60% excellent
        Profit Factor: <1.0 losing, 1.0-1.5 marginal, 1.5-2.0 good, >2.0 excellent

    Examples:
        result = BacktestResult(
            total_return=Decimal("0.25"),  # 25%
            annualized_return=Decimal("0.50"),  # 50% annualized
            max_drawdown=Decimal("0.15"),  # 15%
            max_drawdown_duration=timedelta(days=30),
            sharpe_ratio=Decimal("1.5"),
            sortino_ratio=Decimal("2.0"),
            calmar_ratio=Decimal("3.33"),
            total_trades=100,
            win_rate=Decimal("0.55"),  # 55%
            profit_factor=Decimal("1.8"),
            avg_trade_return=Decimal("0.0025"),  # 0.25%
            start_date=datetime(2024, 1, 1),
            end_date=datetime(2024, 12, 31),
            initial_capital=Decimal("10000"),
            final_capital=Decimal("12500"),
        )
    """

    # === Returns ===
    total_return: Decimal  # Total return as decimal (0.25 = 25%)
    annualized_return: Decimal  # CAGR (Compound Annual Growth Rate)

    # === Risk Metrics ===
    max_drawdown: Decimal  # Maximum peak-to-trough decline (0.15 = 15%)
    max_drawdown_duration: timedelta  # Longest drawdown period

    # === Risk-Adjusted Returns ===
    sharpe_ratio: Decimal  # (return - risk_free) / volatility
    sortino_ratio: Decimal  # Uses downside deviation only
    calmar_ratio: Decimal  # annualized_return / max_drawdown

    # === Trade Statistics ===
    total_trades: int  # Total number of completed trades
    win_rate: Decimal  # Winning trades / total trades (0.55 = 55%)
    profit_factor: Decimal  # Gross profit / gross loss
    avg_trade_return: Decimal  # Average return per trade

    # === Time Period ===
    start_date: datetime
    end_date: datetime

    # === Capital ===
    initial_capital: Decimal
    final_capital: Decimal

    # === Optional Time Series (for visualization) ===
    equity_curve: list[Decimal] = field(default_factory=list)
    drawdown_series: list[Decimal] = field(default_factory=list)
    returns_series: list[Decimal] = field(default_factory=list)

    # === Additional Statistics ===
    winning_trades: int = 0
    losing_trades: int = 0
    avg_winning_trade: Decimal = Decimal("0")
    avg_losing_trade: Decimal = Decimal("0")
    largest_winning_trade: Decimal = Decimal("0")
    largest_losing_trade: Decimal = Decimal("0")
    avg_trade_duration: timedelta | None = None
    volatility: Decimal = Decimal("0")  # Annualized volatility
    risk_free_rate: Decimal = Decimal("0")  # Used for Sharpe calculation

    @property
    def duration(self) -> timedelta:
        """Total backtest duration."""
        return self.end_date - self.start_date

    @property
    def net_profit(self) -> Decimal:
        """Net profit in currency units."""
        return self.final_capital - self.initial_capital

    @property
    def expectancy(self) -> Decimal:
        """
        Expected value per trade.

        Formula: (win_rate * avg_win) - (loss_rate * avg_loss)
        """
        if self.total_trades == 0:
            return Decimal("0")
        loss_rate = Decimal("1") - self.win_rate
        return (self.win_rate * self.avg_winning_trade) - (
            loss_rate * abs(self.avg_losing_trade)
        )

    @property
    def risk_reward_ratio(self) -> Decimal:
        """Average risk/reward ratio."""
        if self.avg_losing_trade == 0:
            return Decimal("0")
        return abs(self.avg_winning_trade / self.avg_losing_trade)

    def summary(self) -> dict[str, Any]:
        """Return summary dict for display/logging."""
        return {
            "total_return": f"{self.total_return * 100:.2f}%",
            "annualized_return": f"{self.annualized_return * 100:.2f}%",
            "max_drawdown": f"{self.max_drawdown * 100:.2f}%",
            "sharpe_ratio": f"{self.sharpe_ratio:.2f}",
            "sortino_ratio": f"{self.sortino_ratio:.2f}",
            "calmar_ratio": f"{self.calmar_ratio:.2f}",
            "total_trades": self.total_trades,
            "win_rate": f"{self.win_rate * 100:.1f}%",
            "profit_factor": f"{self.profit_factor:.2f}",
            "net_profit": f"{self.net_profit:.2f}",
        }


# =============================================================================
# Strategy Protocol
# =============================================================================


@runtime_checkable
class Strategy(Protocol):
    """
    Unified strategy interface for backtest and live trading.

    This protocol defines the contract that all strategy implementations
    must follow. Use `isinstance(obj, Strategy)` for runtime checking.

    The same strategy code works identically in:
    - Backtesting: Historical data replayed through on_bar/on_tick
    - Paper trading: Simulated execution
    - Live trading: Real exchange execution

    Lifecycle:
        1. __init__: Strategy instantiation with config
        2. on_start: Called once when strategy starts
        3. on_bar/on_tick: Called for each market data update (main logic)
        4. on_stop: Called once when strategy stops
        5. on_reset: Called between backtest runs to reset state

    Examples:
        class SMACrossStrategy:
            def __init__(self, config: StrategyConfig):
                self.config = config
                self.fast_ma: list[Decimal] = []
                self.slow_ma: list[Decimal] = []

            @property
            def name(self) -> str:
                return "sma_cross"

            def on_start(self) -> None:
                self.fast_ma.clear()
                self.slow_ma.clear()

            def on_bar(self, bar: Bar) -> Signal | None:
                # Update MAs and generate signal
                ...

            def on_stop(self) -> None:
                pass

            def on_reset(self) -> None:
                self.fast_ma.clear()
                self.slow_ma.clear()
    """

    # -------------------------------------------------------------------------
    # Properties
    # -------------------------------------------------------------------------

    @property
    def name(self) -> str:
        """
        Strategy identifier.

        Used for logging, event sources, and configuration.
        Should be unique within a trading system.
        """
        ...

    # -------------------------------------------------------------------------
    # Lifecycle Methods
    # -------------------------------------------------------------------------

    def on_start(self) -> None:
        """
        Called once when strategy starts.

        Use for:
        - Initializing indicators
        - Subscribing to data feeds
        - Loading saved state
        - Setting up resources

        Note: Called before any market data is received.
        Any exception will be logged and reraised.
        """
        ...

    def on_stop(self) -> None:
        """
        Called once when strategy stops.

        Use for:
        - Cancelling open orders
        - Closing positions (if desired)
        - Saving state
        - Releasing resources

        Note: Should be idempotent (safe to call multiple times).
        Any exception will be logged and reraised.
        """
        ...

    def on_reset(self) -> None:
        """
        Reset strategy state between backtest runs.

        Use for:
        - Clearing indicator buffers
        - Resetting counters
        - Clearing cached state

        Note: Called before on_start for each new backtest run.
        """
        ...

    # -------------------------------------------------------------------------
    # Data Handlers
    # -------------------------------------------------------------------------

    def on_bar(self, bar: Bar) -> Signal | None:
        """
        Process OHLCV bar data.

        This is the main entry point for bar-based strategies.
        Called for each new bar (candle) of market data.

        Args:
            bar: OHLCV bar data

        Returns:
            Signal if strategy wants to trade, None otherwise.

        Note: Should be fast - avoid heavy computation.
        """
        ...

    def on_tick(self, tick: Tick) -> Signal | None:
        """
        Process tick/quote data.

        Optional method for tick-based strategies.
        Called for each new tick of market data.

        Args:
            tick: Real-time tick data

        Returns:
            Signal if strategy wants to trade, None otherwise.

        Note: Called very frequently in live trading - must be fast.
        """
        ...

    # -------------------------------------------------------------------------
    # State Persistence (Optional)
    # -------------------------------------------------------------------------

    def on_save(self) -> dict[str, bytes]:
        """
        Save strategy state for persistence.

        Called periodically and before shutdown.
        Override to save indicator values, positions, etc.

        Returns:
            Dict of state key -> serialized bytes
        """
        ...

    def on_load(self, state: dict[str, bytes]) -> None:
        """
        Load strategy state from persistence.

        Called on startup if saved state exists.
        Override to restore indicator values, positions, etc.

        Args:
            state: Dict of state key -> serialized bytes
        """
        ...


# =============================================================================
# Bar Data Structure
# =============================================================================


class Bar(msgspec.Struct, frozen=True, gc=False):
    """
    OHLCV bar (candlestick) data.

    Immutable, hashable, and optimized for fast serialization.

    Attributes:
        symbol: Trading pair (e.g., "BTC/USDT")
        timestamp_ns: Bar open time (nanoseconds since epoch)
        open: Opening price
        high: Highest price
        low: Lowest price
        close: Closing price
        volume: Trading volume
        timeframe: Bar timeframe (e.g., "1m", "1h", "1d")

    Examples:
        bar = Bar(
            symbol="BTC/USDT",
            timestamp_ns=time.time_ns(),
            open=Decimal("50000"),
            high=Decimal("50500"),
            low=Decimal("49800"),
            close=Decimal("50200"),
            volume=Decimal("100.5"),
            timeframe="1h",
        )
    """

    symbol: str
    timestamp_ns: int
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    timeframe: str

    # Optional fields
    trades: int | None = None  # Number of trades in bar
    vwap: Decimal | None = None  # Volume-weighted average price
    turnover: Decimal | None = None  # Quote volume (volume * price)

    @property
    def timestamp_sec(self) -> float:
        """Timestamp in seconds (float) for compatibility."""
        return self.timestamp_ns / 1_000_000_000

    @property
    def hl2(self) -> Decimal:
        """(High + Low) / 2 - typical price."""
        return (self.high + self.low) / 2

    @property
    def hlc3(self) -> Decimal:
        """(High + Low + Close) / 3 - typical price."""
        return (self.high + self.low + self.close) / 3

    @property
    def ohlc4(self) -> Decimal:
        """(Open + High + Low + Close) / 4 - average price."""
        return (self.open + self.high + self.low + self.close) / 4

    @property
    def range(self) -> Decimal:
        """High - Low price range."""
        return self.high - self.low

    @property
    def body(self) -> Decimal:
        """Absolute candle body size."""
        return abs(self.close - self.open)

    @property
    def is_bullish(self) -> bool:
        """Check if bar is bullish (close > open)."""
        return self.close > self.open

    @property
    def is_bearish(self) -> bool:
        """Check if bar is bearish (close < open)."""
        return self.close < self.open


# =============================================================================
# Strategy Configuration
# =============================================================================


@dataclass
class StrategyConfig:
    """
    Base configuration for strategies.

    Separates configuration from runtime state, enabling:
    - Distributed backtesting
    - Remote deployment
    - Configuration persistence
    - Parameter optimization

    Subclass this for strategy-specific configuration.

    Examples:
        @dataclass
        class SMACrossConfig(StrategyConfig):
            fast_period: int = 10
            slow_period: int = 20
            position_size: Decimal = Decimal("0.1")
    """

    # Required fields
    symbol: str  # Trading pair (e.g., "BTC/USDT")

    # Optional common fields
    timeframe: str = "1h"  # Default timeframe
    max_position_size: Decimal = Decimal("1.0")  # Max position as decimal
    risk_per_trade: Decimal = Decimal("0.02")  # 2% risk per trade


# =============================================================================
# Encoders/Decoders
# =============================================================================

# Fast JSON serialization for strategy types
_encoder = msgspec.json.Encoder()
_signal_decoder = msgspec.json.Decoder(Signal)
_bar_decoder = msgspec.json.Decoder(Bar)


def encode_signal(signal: Signal) -> bytes:
    """Encode Signal to JSON bytes."""
    return _encoder.encode(signal)


def decode_signal(data: bytes) -> Signal:
    """Decode Signal from JSON bytes."""
    return _signal_decoder.decode(data)


def encode_bar(bar: Bar) -> bytes:
    """Encode Bar to JSON bytes."""
    return _encoder.encode(bar)


def decode_bar(data: bytes) -> Bar:
    """Decode Bar from JSON bytes."""
    return _bar_decoder.decode(data)
