"""
Strategy Signal Log Widget.

Displays recent trading signals for a strategy (Issue #43).

Features:
- Signal type with color coding (BUY/SELL/CLOSE)
- Timestamp display
- Entry price, SL/TP levels
- Signal reason/notes
- Filtering by signal type
"""

from __future__ import annotations

import random
import time
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import TYPE_CHECKING, ClassVar

from textual.app import ComposeResult
from textual.binding import Binding
from textual.containers import Container, Horizontal
from textual.message import Message
from textual.reactive import reactive
from textual.widgets import DataTable, Select, Static

if TYPE_CHECKING:
    from textual.widgets.data_table import RowKey


# =============================================================================
# Signal Types
# =============================================================================


class SignalType(str, Enum):
    """Types of trading signals."""

    BUY = "BUY"
    SELL = "SELL"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"
    SCALE_IN = "SCALE_IN"
    SCALE_OUT = "SCALE_OUT"


SIGNAL_COLORS: dict[SignalType, str] = {
    SignalType.BUY: "green",
    SignalType.SELL: "red",
    SignalType.CLOSE_LONG: "yellow",
    SignalType.CLOSE_SHORT: "yellow",
    SignalType.SCALE_IN: "cyan",
    SignalType.SCALE_OUT: "magenta",
}

SIGNAL_ICONS: dict[SignalType, str] = {
    SignalType.BUY: "▲",
    SignalType.SELL: "▼",
    SignalType.CLOSE_LONG: "✕",
    SignalType.CLOSE_SHORT: "✕",
    SignalType.SCALE_IN: "+",
    SignalType.SCALE_OUT: "-",
}


# =============================================================================
# Signal Data Structure
# =============================================================================


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        signal_type: Type of signal (BUY, SELL, etc.)
        symbol: Trading pair (e.g., "BTC/USDT")
        timestamp_ns: Signal generation time in nanoseconds
        entry_price: Suggested entry price
        stop_loss: Stop loss price level
        take_profit: Take profit price level
        quantity: Suggested position size
        reason: Signal generation reason/notes
        signal_id: Unique identifier
        executed: Whether signal was executed
    """

    signal_type: SignalType
    symbol: str
    timestamp_ns: int
    entry_price: Decimal | None = None
    stop_loss: Decimal | None = None
    take_profit: Decimal | None = None
    quantity: Decimal | None = None
    reason: str = ""
    signal_id: str = ""
    executed: bool = False

    def __post_init__(self) -> None:
        if not self.signal_id:
            self.signal_id = f"SIG-{self.timestamp_ns % 1000000:06d}"

    @property
    def timestamp_str(self) -> str:
        """Format timestamp as human-readable string."""
        dt = datetime.fromtimestamp(self.timestamp_ns / 1e9)
        return dt.strftime("%H:%M:%S")

    @property
    def date_str(self) -> str:
        """Format date as human-readable string."""
        dt = datetime.fromtimestamp(self.timestamp_ns / 1e9)
        return dt.strftime("%Y-%m-%d")

    @property
    def color(self) -> str:
        """Get color for this signal type."""
        return SIGNAL_COLORS.get(self.signal_type, "white")

    @property
    def icon(self) -> str:
        """Get icon for this signal type."""
        return SIGNAL_ICONS.get(self.signal_type, "•")

    @property
    def formatted_type(self) -> str:
        """Format signal type with color and icon."""
        return f"[{self.color}]{self.icon} {self.signal_type.value}[/{self.color}]"

    @property
    def formatted_entry(self) -> str:
        """Format entry price."""
        if self.entry_price is None:
            return "-"
        return f"${self.entry_price:,.2f}"

    @property
    def formatted_sl(self) -> str:
        """Format stop loss."""
        if self.stop_loss is None:
            return "-"
        return f"${self.stop_loss:,.2f}"

    @property
    def formatted_tp(self) -> str:
        """Format take profit."""
        if self.take_profit is None:
            return "-"
        return f"${self.take_profit:,.2f}"


# =============================================================================
# Signal Log Widget
# =============================================================================


class StrategySignalLog(Container):
    """
    Scrollable log of trading signals.

    Features:
    - DataTable with signal history
    - Filter by signal type
    - Color-coded signal types
    - Click to see signal details
    """

    DEFAULT_CSS = """
    StrategySignalLog {
        height: 100%;
        width: 100%;
        layout: vertical;
    }

    StrategySignalLog .signal-header {
        height: 3;
        padding: 0 1;
        background: $surface-darken-1;
    }

    StrategySignalLog .signal-title {
        width: auto;
        padding-right: 2;
        text-style: bold;
    }

    StrategySignalLog .filter-select {
        width: 15;
    }

    StrategySignalLog .signal-table {
        height: 1fr;
    }

    StrategySignalLog DataTable {
        height: 100%;
    }

    StrategySignalLog .signal-footer {
        height: 1;
        padding: 0 1;
        background: $surface-darken-1;
        color: $text-muted;
    }

    StrategySignalLog .no-signals {
        height: 100%;
        width: 100%;
        content-align: center middle;
        color: $text-muted;
    }
    """

    BINDINGS: ClassVar[list[Binding]] = [
        Binding("r", "refresh", "Refresh"),
        Binding("c", "clear_filter", "Clear Filter"),
    ]

    # Reactive state
    filter_type: reactive[SignalType | None] = reactive(None, init=False)

    class SignalSelected(Message):
        """Message sent when a signal is selected."""

        def __init__(self, signal: Signal) -> None:
            super().__init__()
            self.signal = signal

    def __init__(
        self,
        signals: list[Signal] | None = None,
        title: str = "RECENT SIGNALS",
        id: str | None = None,
    ) -> None:
        super().__init__(id=id)
        self._signals: list[Signal] = signals or []
        self._filtered_signals: list[Signal] = []
        self._title = title
        self._row_to_signal: dict[RowKey, Signal] = {}

    def compose(self) -> ComposeResult:
        # Header with title and filter
        with Horizontal(classes="signal-header"):
            yield Static(self._title, classes="signal-title")
            yield Select(
                [("All Signals", None)]
                + [(f"{SIGNAL_ICONS[t]} {t.value}", t) for t in SignalType],
                value=None,
                id="filter-type",
                classes="filter-select",
            )

        # Table or empty message
        if not self._signals:
            yield Static("No recent signals", classes="no-signals", id="no-signals")
        else:
            with Container(classes="signal-table"):
                yield DataTable(id="signals-table", cursor_type="row", zebra_stripes=True)

        # Footer with stats
        yield Static(self._get_footer_text(), id="signal-footer", classes="signal-footer")

    def on_mount(self) -> None:
        """Set up the table on mount."""
        try:
            table = self.query_one("#signals-table", DataTable)
            table.add_column("Time", key="time")
            table.add_column("Type", key="type")
            table.add_column("Symbol", key="symbol")
            table.add_column("Entry", key="entry")
            table.add_column("SL", key="sl")
            table.add_column("TP", key="tp")
            table.add_column("Reason", key="reason")

            self._apply_filter()
            self._populate_table()
        except Exception:
            pass

    def _get_footer_text(self) -> str:
        """Generate footer statistics."""
        total = len(self._signals)
        filtered = len(self._filtered_signals)

        if total == 0:
            return "No signals"

        buy_count = sum(1 for s in self._filtered_signals if s.signal_type == SignalType.BUY)
        sell_count = sum(1 for s in self._filtered_signals if s.signal_type == SignalType.SELL)
        executed = sum(1 for s in self._filtered_signals if s.executed)

        return (
            f"Showing {filtered}/{total}  |  "
            f"[green]Buy: {buy_count}[/green]  "
            f"[red]Sell: {sell_count}[/red]  "
            f"Executed: {executed}"
        )

    def _apply_filter(self) -> None:
        """Apply current filter to signals."""
        if self.filter_type is None:
            self._filtered_signals = self._signals.copy()
        else:
            self._filtered_signals = [
                s for s in self._signals if s.signal_type == self.filter_type
            ]

        # Sort by timestamp descending (newest first)
        self._filtered_signals.sort(key=lambda s: s.timestamp_ns, reverse=True)

    def _populate_table(self) -> None:
        """Populate table with filtered signals."""
        try:
            table = self.query_one("#signals-table", DataTable)
        except Exception:
            return

        table.clear()
        self._row_to_signal.clear()

        for signal in self._filtered_signals[:50]:  # Limit to 50 most recent
            row_key = table.add_row(
                signal.timestamp_str,
                signal.formatted_type,
                signal.symbol,
                signal.formatted_entry,
                signal.formatted_sl,
                signal.formatted_tp,
                signal.reason[:30] + "..." if len(signal.reason) > 30 else signal.reason,
                key=signal.signal_id,
            )
            self._row_to_signal[row_key] = signal

        # Update footer
        try:
            footer = self.query_one("#signal-footer", Static)
            footer.update(self._get_footer_text())
        except Exception:
            pass

    def on_select_changed(self, event: Select.Changed) -> None:
        """Handle filter change."""
        if event.select.id == "filter-type":
            value = event.value
            if value is None or isinstance(value, SignalType):
                self.filter_type = value
                self._apply_filter()
                self._populate_table()

    def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
        """Handle signal selection."""
        if event.row_key in self._row_to_signal:
            signal = self._row_to_signal[event.row_key]
            self.post_message(self.SignalSelected(signal))

    def action_refresh(self) -> None:
        """Refresh the signal list."""
        self._apply_filter()
        self._populate_table()

    def action_clear_filter(self) -> None:
        """Clear the filter."""
        self.filter_type = None
        try:
            select = self.query_one("#filter-type", Select)
            select.value = None
        except Exception:
            pass
        self._apply_filter()
        self._populate_table()

    def update_signals(self, signals: list[Signal]) -> None:
        """Update with new signals."""
        self._signals = signals
        self._apply_filter()
        self._populate_table()

    def add_signal(self, signal: Signal) -> None:
        """Add a new signal to the log."""
        self._signals.insert(0, signal)
        self._apply_filter()
        self._populate_table()

    def clear_signals(self) -> None:
        """Clear all signals."""
        self._signals = []
        self._filtered_signals = []
        self._populate_table()


# =============================================================================
# Demo Signal Generator
# =============================================================================


def create_demo_signals(count: int = 10, symbol: str = "BTC/USDT") -> list[Signal]:
    """
    Create demo signals for testing.

    Args:
        count: Number of signals to generate
        symbol: Trading symbol

    Returns:
        List of demo Signal objects
    """
    signals = []
    base_price = Decimal("50000")
    base_time = time.time_ns()

    reasons = [
        "SMA crossover detected",
        "RSI oversold bounce",
        "Support level test",
        "Resistance breakout",
        "Volume spike detected",
        "MACD histogram reversal",
        "Trend continuation pattern",
        "Mean reversion signal",
        "Momentum divergence",
        "Price action pattern",
    ]

    for i in range(count):
        # Randomize signal type
        signal_type = random.choice(list(SignalType))

        # Random price around base
        price_offset = Decimal(str(random.uniform(-2000, 2000)))
        entry_price = base_price + price_offset

        # Calculate SL/TP based on signal type
        if signal_type in (SignalType.BUY, SignalType.SCALE_IN):
            stop_loss = entry_price * Decimal("0.98")  # 2% below
            take_profit = entry_price * Decimal("1.04")  # 4% above
        else:
            stop_loss = entry_price * Decimal("1.02")  # 2% above
            take_profit = entry_price * Decimal("0.96")  # 4% below

        signal = Signal(
            signal_type=signal_type,
            symbol=symbol,
            timestamp_ns=base_time - (i * 300_000_000_000),  # 5 min apart
            entry_price=entry_price.quantize(Decimal("0.01")),
            stop_loss=stop_loss.quantize(Decimal("0.01")),
            take_profit=take_profit.quantize(Decimal("0.01")),
            quantity=Decimal(str(random.uniform(0.01, 0.5))).quantize(Decimal("0.001")),
            reason=random.choice(reasons),
            executed=random.random() > 0.3,  # 70% executed
        )
        signals.append(signal)

    return signals
